// this file contains basic grammar for the language
// that will be implemented in the future

fn fib (number) => number;
// ^ this is a prototype, the thingy
// which tells the interpreter what the
// function takes in and what it returns

fn fib 0 = 1;
fn fib 1 = 1;
// ^ these two are specialized cases
// of `fib`

fn fib n = fib(n - 1) + fib(n - 2);
// ^ this is the generic implementation
// it will be called when the parameter
// of `fib` isn't 0 or 1

module loop {
    import builtin.never; // never means that the function is never going to return

    // Represents whether `run` should stop or continue 
    // the current loop. Accessing fields is forbidden, use `break` or 
    // `continue` to create new instances.
    @lang(loop_state)
    @private_constructor
    type LoopState<T, R> = Continue(T) | Break(R);

    // Represents a type that means that the loop should continue running forever.
    // If you are using this with `run` consider using `forever` instead.
    @lang(forever) type Forever = ();

    // Break the current loop and return `r`.
    fn break r = LoopState.Break(r);
    // Continue the current loop with the state `c`.
    fn continue c = LoopState.Continue(c);

    // Run a function in a loop until the given function 
    // returns `LoopState.Break(...)`. If your function doesn't 
    // a lot of iteration use recursion instead.
    // ```
    // fn loop_inner 0 sum = loop.break(sum);
    // fn loop_inner i sum = loop.continue((i - 1, sum + i));
    // const sum_of_ten = loop.run((10, 0), &loop_inner);
    // // the value of this `const` is 55. 
    // ```
    @lang(loop_run) fn run<T, R> (T, (T) => LoopState<T, R>) => R;
    // Run a function in a loop & pass state between iterations. 
    @lang(loop_forever) fn forever<S> (S) => S => never;

    export { LoopState, Forever, break, continue, run, forever };
};

// range is the type of `begin..end` expressions
// IO is an opaque builtin types that represents 
// the handle on input/output, having a system
// like this prevents `const`s from using print/input
// statements, thus forbidding mutability
fn fizz_buzz (IO, number, range<number>) => IO; 

// its a good practice to return IOs from functions that take IO as a parameter
// because that allows chaining functions: debug()
fn fizz_buzz io, num, range = 
    if !has(range, num): return io else num;
    => if $ % 15 == 0: debugln(io, "Fizz Buzz")
        else if $ % 3 == 0: debugln(io, "Fizz")
        else if $ % 5 == 0: debugln(io, "Buzz")
        else debugln(io, stringify($))
    => fizz_buzz(num + 1, range);

// => places the first parameter of a function
// eg 10 => sin, however this doesnt work with mutliple function calls
// or when you want to place the result as the second/third/etc 
// param, use $ in these cases, eg 10 => sin($) + cos($) is sin(10) + cos(10)
//
// `lock_stdout` returns an IO that allows you to write to stdout
// IO is buffered, `close` flushes the IO and drops it in memory
fn main = lock_stdout => fizz_buzz(1, 1..15) => close;

type Option<T> = Some(T) | None;

// convert - allows to convert between objects of different types
@derive(Convert)
type Example = {
    inner_opt: Option<IO>,
    inner: number,
};

// traits provide a way to define common behaviour between types
// here you can access the defined functions via Foo
// eg. `const a = Foo.default<T>()` where T is a type that implements `Foo`
// `const b = Foo.bar(a)`
// `self` refers to the implementing type
trait Foo = {
    fn default () => self;
    fn bar (self) => self;
};

// this implements Foo for Example
impl Example < Foo = {
    fn default = self { inner_opt: None, inner: 0 };
    fn bar caller = self { inner_opt: caller.inner_opt, inner: caller.inner + 1 };
};

const example = Foo.default<Example>(); // { None, 0 }
const example2 = Foo.bar(example); // { None, 1 }

@derive(Convert)
type SmallerExample = {
    inner: number,
};

impl SmallerExample < Foo {
    fn default = self { inner: 0 };
    fn bar caller = self { inner: caller.inner + 1 };
}

fn convert_normal_to_small (Example) => SmallerExample;
fn convert_normal_to_small normal = 
    convert_to(normal, &SmallerExample) => unwrap;

// `convert_to` returns an option, because in some cases 
// the first parameter may not always have enough valid fields
// to be converted into a parameter of the given type
// so we call unwrap; unwrap either returns a valid value
// or panics (stops the whole program)
// the `&` operator is used for meta functions, those that can 
// be used to achieve compiler magic and stuff like that
// here &SmallerExample returns an expression of type `Type`
// that contains all the info about the object's type
// previously in this file & was used to pass function as a parameter

// pattern matching
type FooBar = Foo(number) | Bar(string) | IFoo(IO) | Other;

fn func (FooBar) => string;
fn func foobar = match foobar 
    case Foo(n): $"foobar is the number {n}",
    case Bar(s): $"foobar is a string \"{s}\"",
    case IFoo(_): $"foobar is an IO instance",
    case Other: $"foobar is uhhh";

const foobar = FooBar.Foo(10);
fn main = lock_stdout => foobar => debugln => close; 
// ^ will print "foobar is the number 10"

// this is an interface, it is its own type
// that is a combination of several traits,
// an interface contains the object it was built from 
// and the various implementation details
// for example here `number` is an interface that requires all
// the various traits that get associated with numbers
interface number = Add & Sub & Div & Mult & Display & Round;

// this trait is defined by the language so it can be used 
// in compiler magic, essentially any expression like `a + b`
// gets resolved to `Add.add(a, b)`
trait Add {
    fn add (self, self) => self;
}

// an `int` or a `float` could be turned into a `number`
const num = number(10);
const num2 = number(5.5);
// const result = num + num2; 
// ^ this will throw an error because `add` is strict
const num3 = number(5.1);
const result = num2 + num2;
// result will have the type number, which is resolved to 
// interface<Add, Sub, Div, Mult, Display, Round>, and actually
// contains an object of type `float` inside, the value of the 
// float is 10.6

// when interfaces are declared with a unit it means that
// every object can be converted into this interface
interface any = ();

// interface<> objects can be cast back into the 
// original objects
import dyn; // fn cast<T> (interface<()>) => Option<T>
const ten_point_six = unwrap(cast<float>(result));
// ^ float, has the value 10.6

// file handling 
@no_copy
@private_constructor
type IO = { ... };
type IOError = { ... };
@no_copy
@private_constructor
type File = { ... };

trait WriteIO = {
    fn write (self, bytes) => Result<int, IOError>;
    fn flush (self) => Result<(), IOError>;
};
// no copy is a trait implemented by @no_copy types
interface writable = WriteIO + NoCopy;

fn io_from_writer (writable) => IO;
// opens a file to write to
fn open_file (Path) => Result<File, IOError>; 

// this function takes a path to a file and writes an array into it
fn write_array_to_file (Path, [displayable]) => Result<(), IOError>;
fn write_array_to_file path array = 
    // ? either returns from the function with this error
    // or returns the good value
    open_file(path)? 
    => io_from_writer 
    => make_buffered // buffered writing to make less os calls overall
    // write => Result.Ok(io)
    => write("[ ")?
    // iterable, state, function
    => loop.for_each(array, $, |io, num| write(io?, f"{num}, "))?
    => write("]")?
    => close 
    => Result.Ok(());

fn test<T> (T) => T;
fn test<T> t = dyn.try_cast<Display>(t) => unwrap => global_debug;


// V2 
// newer version of this language's design

// every write operation returns an IO, which is like a suspended action
// IO is only gonna get evaluated from the main function
// or if your function returns an IO you can use the with statements
// to evaluate them instantly
// IO has type parameters with the default one being unit
fn write_array (Writer, [Display]) => IO<File>;
// file is `Writer` which means that it can be any thing that you can write to
// in `write_array_to_file` you pass a structure of type `File` that gets 
// automatically converted into a `file`
fn write_array file array = with IO 
	=> file // file is now $ 
	=> write("[ ") // write returns IO<File> to make it easier to chain functions
	=> for elem in array do write("{elem}")
	=> write("]");

fn write_array_to_file (Path, [Display]) => IO;
fn write_array_to_file path array = with IO
	=> open_reader(path)
	=> write_array(array)
	=> close; 
	
// fn close (File) => IO;
// `close` drops the file handle, run it whenever you need to get rid of a file


// common problems youd solve in other languages
fn is_even (Number) => bool;
fn is_even n = n % 2 == 0;

fn is_palindrome (string) => bool;
fn is_palindrome str = 	
	length_of(str) // $ is now the length of str
	=> for i in 0..($ / 2) do 
		if get(str, i) != get(str, $ - i - 1) // get ([T], uint) => T;
			then return false
	=> true;
	
fn greet () => IO;
fn greet = with IO
	=> input("enter your name: ") // input (string) => IO<string>;
	=> println(f"Hello, {$}!"); // println (string) => IO;
	
fn sum_from_one_to_n (int) => int;
fn sum_from_one_to_n n = 1..(n + 1) => sum; // sum ([T: Number]) => T;

fn _inner (int, int) => int;
fn _inner a b = 
	if b % 3 == 0 or b % 5 == 0 
		then a + b else a;

fn sum_from_one_to_n_and_check (int) => int;
fn sum_from_one_to_n_and_check n =	
	1..(n + 1)
	=> reduce($, &_inner, 0); // reduce ([T], (T, T) => T, T) => T; 	
	// the second parameter is passed as `a` to _inner

fn mult_table_of (int) => IO;
fn mult_table_of n = with IO
	=> for i in 1..(10 + 1) do	
		println("{n} * {i} = {n * i}")
	=> println("this was the multiplication table of {n}");

fn my_max<T: Number> ([T]) => T;
fn my_max array = array
	=> if length_of($) == 0 then panic("array's length should be > 0!")
	=> reduce($, |a, b| if a > b then a else b, 0);

fn has<T: Eq> ([T], T) => bool;
fn has array elem = 
	for e in array do 
		if e == elem return true
	=> false;

// simple http example
// this assumes that http://example.org/weather checks the current IP
// and returns the weather in form of the later defined `Weather` type
import lib.http;

@convert
type Location = ...;
@convert
type WeatherType = ...;

@convert
type Weather = 
	temperature: int
	& location: Location
	& wtype: Weather;

alias FetchWeather = http.HTTP<Weather>;
// `FetchWeather` and `http.HTTP<Weather>` are the same and can be used interchangebly

fn fetch_weather (http.Client) => FetchWeather; // http.HTTP is a monad like IO
fn fetch_weather client = with http.HTTP	
	=> client
	=> http.fetch_json("http://example.org/weather") // returns HTTP<any>
	=> convert_to<Weather> // Option<Weather>
	=> match $ do
		None -> unreachable(),
		Some(res) -> res;
	// ^ could be replaced with `unwrap`

trait ImageEXT = 
	fn dimensions (self) => (uint, uint)
	& fn resized (self, (uint, uint)) => ImageResult<self>
	& ...;

type Image<SizeT> =
	RGB(RGBImage<SizeT>)
	| HSB(HSBImage<SizeT>)
	| HSL(HSLImage<SizeT>)
	| CMYK(CMYKImage;
	
impl<T> ImageEXT > Image<T> = {
	fn dimensions image = 
		match image do	
			Image.RGB(i) 
			| Image.HSB(i) 
			| Image.HSL(i) 
			| Image.CMYK(i) => super.dimensions(i) 
			// super refers to the currently implemented trait
			
	fn resized image size = ...;
	
	...
};

type Result<T, E> = Ok(T) | Err(E);

module os = {
	type OSError = ...;
	alias OSResult<T> = Result<T, OSError>;

	fn getpid () => int;
	fn kill (int) => OSResult<()>;
	
	...
	
	export { OSError, getpid, kill, ... };
};

// the monad trait allows you to chain functions and modify state
// this trait is implemented by IO, HTTP, Result, Option and eg
// `change` replaces an old value with a new one all while keeping a 
// monad around the types
// `apply` applies a function to self to return a new value
// `return` creates a new monad value
trait Monad<T> with Other = {
	fn change (self<T>, self<Other>) => self<Other>;
	fn apply (self<T>, (T) => self<Other>) => self<Other>;
	fn return (T) => self<T>; 
};

fn modify<T> (Monad<T>, (T) => T) => Monad<T>;
fn modify monad func = 
	Monad.apply( monad, |inner| Monad.return(func(inner)) );

// for example, IO
fn write_array<T> (Writer, [T]) => IO<Writer>;
fn write_array fmt array = with IO 
	// with IO converts all IO<T> values into T but makes it so that the final
	// expression of the function is also an IO
	=> write(fmt, "[ ") // write (Writer, T) => IO<Writer>
	=> for elem in array do // `for` returns an iterator...
		write($, f"{elem}, ") 
	// ...which is then applied to the currently held expression
	// essentially it does Monad.apply(Monad.apply(Monad.apply(...
	// for every element in the iterator
	=> write("]");
