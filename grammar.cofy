// this file contains basic grammar for the language
// that will be implemented in the future

fn fib (number) => number;
// ^ this is a prototype, the thingy
// which tells the interpreter what the
// function takes in and what it returns

fn fib 0 = 1;
fn fib 1 = 1;
// ^ these two are specialized cases
// of `fib`

fn fib n = fib(n - 1) + fib(n - 2);
// ^ this is the generic implementation
// it will be called when the parameter
// of `fib` isn't 0 or 1

module loop {
    import builtin.never; // never means that the function is never going to return

    // Represents whether `run` should stop or continue 
    // the current loop. Accessing fields is forbidden, use `break` or 
    // `continue` to create new instances.
    @lang(loop_state)
    @private_constructor
    type LoopState<T, R> = Continue(T) | Break(R);

    // Represents a type that means that the loop should continue running forever.
    // If you are using this with `run` consider using `forever` instead.
    @lang(forever) type Forever = ();

    // Break the current loop and return `r`.
    fn break r = LoopState.Break(r);
    // Continue the current loop with the state `c`.
    fn continue c = LoopState.Continue(c);

    // Run a function in a loop until the given function 
    // returns `LoopState.Break(...)`. If your function doesn't 
    // a lot of iteration use recursion instead.
    // ```
    // fn loop_inner 0 sum = loop.break(sum);
    // fn loop_inner i sum = loop.continue((i - 1, sum + i));
    // const sum_of_ten = loop.run((10, 0), &loop_inner);
    // // the value of this `const` is 55. 
    // ```
    @lang(loop_run) fn run<T, R> (T, (T) => LoopState<T, R>) => R;
    // Run a function in a loop & pass state between iterations. 
    @lang(loop_forever) fn forever<S> (S) => S => never;

    export { LoopState, Forever, break, continue, run, forever };
};

// range is the type of `begin..end` expressions
// IO is an opaque builtin types that represents 
// the handle on input/output, having a system
// like this prevents `const`s from using print/input
// statements, thus forbidding mutability
fn fizz_buzz (IO, number, range<number>) => IO; 

// its a good practice to return IOs from functions that take IO as a parameter
// because that allows chaining functions: debug()
fn fizz_buzz io, num, range = 
    if !has(range, num): return io else num;
    => if $ % 15 == 0: debugln(io, "Fizz Buzz")
        else if $ % 3 == 0: debugln(io, "Fizz")
        else if $ % 5 == 0: debugln(io, "Buzz")
        else debugln(io, stringify($))
    => fizz_buzz(num + 1, range);

// => places the first parameter of a function
// eg 10 => sin, however this doesnt work with mutliple function calls
// or when you want to place the result as the second/third/etc 
// param, use $ in these cases, eg 10 => sin($) + cos($) is sin(10) + cos(10)
//
// `lock_stdout` returns an IO that allows you to write to stdout
// IO is buffered, `close` flushes the IO and drops it in memory
fn main = lock_stdout => fizz_buzz(1, 1..15) => close;

type Option<T> = Some(T) | None;

// convert - allows to convert between objects of different types
@derive(Convert)
type Example = {
    inner_opt: Option<IO>,
    inner: number,
};

// traits provide a way to define common behaviour between types
// here you can access the defined functions via Foo
// eg. `const a = Foo.default<T>()` where T is a type that implements `Foo`
// `const b = Foo.bar(a)`
// `self` refers to the implementing type
trait Foo = {
    fn default () => self;
    fn bar (self) => self;
};

// this implements Foo for Example
impl Example < Foo = {
    fn default = self { inner_opt: None, inner: 0 };
    fn bar caller = self { inner_opt: caller.inner_opt, inner: caller.inner + 1 };
};

const example = Foo.default<Example>(); // { None, 0 }
const example2 = Foo.bar(example); // { None, 1 }

@derive(Convert)
type SmallerExample = {
    inner: number,
};

impl SmallerExample < Foo {
    fn default = self { inner: 0 };
    fn bar caller = self { inner: caller.inner + 1 };
}

fn convert_normal_to_small (Example) => SmallerExample;
fn convert_normal_to_small normal = 
    convert_to(normal, &SmallerExample) => unwrap;

// `convert_to` returns an option, because in some cases 
// the first parameter may not always have enough valid fields
// to be converted into a parameter of the given type
// so we call unwrap; unwrap either returns a valid value
// or panics (stops the whole program)
// the `&` operator is used for meta functions, those that can 
// be used to achieve compiler magic and stuff like that
// here &SmallerExample returns an expression of type `Type`
// that contains all the info about the object's type
// previously in this file & was used to pass function as a parameter

// pattern matching
type FooBar = Foo(number) | Bar(string) | IFoo(IO) | Other;

fn func (FooBar) => string;
fn func foobar = match foobar 
    case Foo(n): $"foobar is the number {n}",
    case Bar(s): $"foobar is a string \"{s}\"",
    case IFoo(_): $"foobar is an IO instance",
    case Other: $"foobar is uhhh";

const foobar = FooBar.Foo(10);
fn main = lock_stdout => foobar => debugln => close; 
// ^ will print "foobar is the number 10"

// this is an interface, it is its own type
// that is a combination of several traits,
// an interface contains the object it was built from 
// and the various implementation details
// for example here `number` is an interface that requires all
// the various traits that get associated with numbers
interface number = Add & Sub & Div & Mult & Display & Round;

// this trait is defined by the language so it can be used 
// in compiler magic, essentially any expression like `a + b`
// gets resolved to `Add.add(a, b)`
trait Add {
    fn add (self, self) => self;
}

// an `int` or a `float` could be turned into a `number`
const num = number(10);
const num2 = number(5.5);
// const result = num + num2; 
// ^ this will throw an error because `add` is strict
const num3 = number(5.1);
const result = num2 + num2;
// result will have the type number, which is resolved to 
// interface<Add, Sub, Div, Mult, Display, Round>, and actually
// contains an object of type `float` inside, the value of the 
// float is 10.6

// when interfaces are declared with a unit it means that
// every object can be converted into this interface
interface any = ();

// interface<> objects can be cast back into the 
// original objects
import dyn; // fn cast<T> (interface<()>) => Option<T>
const ten_point_six = unwrap(cast<float>(result));
// ^ float, has the value 10.6

// file handling 
@no_copy
@private_constructor
type IO = { ... };
type IOError = { ... };
@no_copy
@private_constructor
type File = { ... };

trait WriteIO = {
    fn write (self, bytes) => Result<int, IOError>;
    fn flush (self) => Result<(), IOError>;
};
// no copy is a trait implemented by @no_copy types
interface writable = WriteIO + NoCopy;

fn io_from_writer (writable) => IO;
// opens a file to write to
fn open_file (Path) => Result<File, IOError>; 

// this function takes a path to a file and writes an array into it
fn write_array_to_file (Path, [displayable]) => Result<(), IOError>;
fn write_array_to_file path array = 
    // ? either returns from the function with this error
    // or returns the good value
    open_file(path)? 
    => io_from_writer 
    => make_buffered // buffered writing to make less os calls overall
    // write => Result.Ok(io)
    => write("[ ")?
    // iterable, state, function
    => loop.for_each(array, $, |io, num| write(io?, f"{num}, "))?
    => write("]")?
    => close 
    => Result.Ok(());

fn test<T> (T) => T;
fn test<T> t = dyn.try_cast<Display>(t) => unwrap => global_debug;
